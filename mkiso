#! /bin/sh


#	Exit on error.

set -e

_e () { echo -e "${0##*/}: \e[31mError:\e[0m $@" >&2; exit 1; }


#	Option parsing.

while :; do
	case $1 in

		-V)
			label=$2
			shift 2
		;;

		-g)
			config_files="$config_files $2"
			shift 2
		;;

		-t)
			themes="$themes $2"
			shift 2
		;;

		-u)
			update_url="$2"
			shift 2
		;;

		-s)
			hash_url="$2"
			shift 2
		;;

		-r)
			release="$2"
			shift 2
		;;

		-b)
			bios=y
			shift
		;;

		-e)
			uefi=y
			shift
		;;

		-d|--debug)
			set -x
			shift
		;;

		-h|--help)
			echo "${0##*/}: Generate an ISO image from a directory."
			echo "Usage: ${0##*/} [flags]  <directory> <output>"
			echo
			echo "-h, --help       Show this help. "
			echo "-d, --debug      Enable debugging messages."
			echo "-b               Enable BIOS support."
			echo "-e               Enable UEFI support."
			echo "-V <label>       Set the filesystem label to <label>."
			echo "-g <file>        Use <file> as a GRUB configuration file."
			echo "-t <path>        Use <path> as a GRUB theme."
			echo "-u <update_url>  For use with znx."
			echo "-s <hash_url>    For use with znx."
			echo "-r <release>     For use with znx."
			exit
		;;

		-*) _e "Unknown option '$1'.";;

		*) break;;

	esac
done


#	Check the command line.

iso_dir="$1"
output="$2"

test $# -eq 2 ||
	_e "Bad command line. Wrong number of arguments."

test -d "$iso_dir" ||
	_e "'$iso_dir' is not a directory."


#	Copy the configuration files.

test "$config_files" && {
	mkdir -p "$iso_dir"/boot/grub
	cp $config_files "$iso_dir"/boot/grub
}


#	Copy the themes.

test "$themes" && {
	mkdir -p "$iso_dir"/boot/grub/themes
	cp -r $themes "$iso_dir"/boot/grub/themes
}


#	Create the .INFO file if needed.

test "$hash_url" && echo "HASH_URL $hash_url" >> "$iso_dir/.INFO"
test "$update_url" && echo "UPDATE_URL $update_url" >> "$iso_dir/.INFO"
test "$release" && echo "RELEASE $release" >> "$iso_dir/.INFO"


#	GRUB2 modules.

_bios_mods="biosdisk boot linux search normal configfile part_gpt btrfs ext2 fat iso9660 loopback test keystatus gfxmenu regexp probe all_video gfxterm font echo read ls cat png jpeg halt reboot"
_uefi_mods="efi_gop efi_uga boot linux search normal configfile part_gpt btrfs ext2 fat iso9660 loopback test keystatus gfxmenu regexp probe all_video gfxterm font echo read ls cat png jpeg halt reboot"


#	Generate boot artifacts.

test "$bios" = y && {
	bios_img=bios.img

	grub-mkimage \
		-O i386-pc-eltorito \
		-o "$iso_dir/$bios_img" \
		-p /boot/grub \
		$_bios_mods

	bios_opts="
		-eltorito-alt-boot
		-b bios.img
		-no-emul-boot
		-graft-points bios.img=$iso_dir/$bios_img
		-boot-load-size 4
		-boot-info-table
		-c boot.cat
		--grub2-boot-info
		--grub2-mbr /usr/lib/grub/i386-pc/boot_hybrid.img
	"
}


test "$uefi" = y && {
	efi_img=$(mktemp)

	grub-mkimage \
		-O x86_64-efi \
		-o "$efi_img" \
		-p /boot/grub \
		$_uefi_mods

	export MTOOLS_SKIP_CHECK=1
	mkfs.vfat \
		-C "$iso_dir/efi.img" \
		$(( $(wc -c < $efi_img) / 1024 + 511))

	mmd \
		-i "$iso_dir/efi.img" \
		efi \
		efi/boot

	mcopy \
		-i "$iso_dir/efi.img" \
		"$efi_img" \
		::efi/boot/bootx64.efi

	uefi_opts="
		-eltorito-alt-boot
		-no-emul-boot
		-e efi.img
		-graft-points efi.img=$iso_dir/efi.img
		-append_partition 2 0xef $iso_dir/efi.img
	"
}


#	Generate ISO image.

xorriso \
	-as mkisofs \
	-iso-level 3 \
	-full-iso9660-filenames \
	-volid "$label" \
	-o "$output" \
	"$iso_dir" \
	$bios_opts \
	$uefi_opts
