#! /bin/sh


set -e
_e () { printf "${0##*/}: \e[31mError:\e[0m %s\n" "$*" >&2; exit 1; }

case "$1" in
	-h|--help)
		printf "%s\n" \
			"${0##*/}: generate the ISO image described in the given file." \
			"" \
			"usage:" \
			"  ${0##*/} [-h|--help]  show this help." \
			"  ${0##*/} <file> [img]"
		exit
	;;
esac


#	functions.

get_k () { echo "$desc" | grep "$1" | cut -d " " -f 2-; }


setup_base () {
	sys_base=$(get_k BASE)

	case "$sys_base" in
		@URL:*)
			tmp=$(mktemp)
			wget -qO $tmp "${sys_base#@URL:}"
			tar xf $tmp -C $tmp_root
		;;

		@LOCAL:*) tar xf "${sys_base#@LOCAL:}" -C $tmp_root;;
		*) pull $tmp_root $sys_base;;
	esac

	test -x "${input%/*}/prepare.sh" || return

	cp "${input%/*}/prepare.sh" $tmp_root
	runch $tmp_root /prepare.sh
	rm -rf $tmp_root/prepare.sh
}


install_pkgs () {
	pm=$(get_k PACKAGE_MANAGER)
	pkgs=$(get_k PACKAGES)

	case "$pm" in
		pacman)
			pm_u="$pm --noconfirm -Syu"
			pm_i="$pm --noconfirm -S"
		;;

		apt)
			pm_u="$pm -y upgrade"
			pm_i="$pm -y install"
		;;

		apk)
			pm_u="$pm update"
			pm_i="$pm add"
		;;

		"")
			printf "%s\n" \
				" :: warning:" \
				"    no package manager specified."
			return
		;;

		?*) _e "unsupported package manager '$pm'. aborting.";;
	esac

	runch $tmp_root $pm_u

	test "$pkgs" || {
		printf "%s\n" \
			" :: warning:" \
			"    no additional packages were specified."
		return
	}

	runch $tmp_root $pm_i $pkgs

	test -x "${input%/*}/finish.sh" &&
		runch \
			-m "${input%/*}/finish.sh":/finish.sh  \
			-r /finish.sh \
			$tmp_root /finish.sh
}


setup_bootloader () {
	get_k BOOT_FILES | while read item; do
		src="$tmp_root/${item%=>*}"
		dst="$iso_dir/${item#*=>}"
		src_path="${src%/*}"
		dst_path="${dst%/*}"

		test -e "$src" ||
			_e "'$src' does not exist."

		mkdir -p "$dst_path"
		cp -r "$src" "$dst"
	done
}


#	setup the build.

root_sfs=rootfs.sfs
tmp_root=$(mktemp -d $(pwd)/.tmp.XXXX)
iso_dir=$(mktemp -d $(pwd)/.tmp.XXXX)

input="${1:-synthfile}"
output="${2:-${1%.synth}.iso}"


#	remove waste after the build.

trap "rm -rf $tmp_root $iso_dir" EXIT HUP INT TERM

test -f "$input" ||
	_e "'$input' is not a file."

test -e "$output" &&
	_e "'$output' already exists."


#	start the build.

desc=$(
	sed -E \
		-e ":x N" \
		-e "/,$/ b x" \
		-e "/[A-Z_][ \t]*$/ b x" \
		-e "s/,\n[ \t]*/ /g" \
		-e "s/([A-Z_]+)\n*[ \t]*/\1 /g" \
		-e "s/[ \t]*->[ \t]*/->/g" \
	"$input"
)

setup_base
install_pkgs
setup_bootloader


#	all done. generate the artifacts.

mksquashfs \
	$tmp_root \
	$iso_dir/$root_sfs \
	-b 1M \
	-comp xz \
	-no-progress


mkiso \
	-u "$(get_k UPDATE_URL)" \
	-s "$(get_k HASH_URL)" \
	-r "$(get_k RELEASE)" \
	$(test $(get_k BIOS_BOOT) = on && echo "-b") \
	$(test $(get_k UEFI_BOOT) = on && echo "-e") \
	$iso_dir \
	"$output"


zsyncmake \
	"$output" \
	-u "$(get_k UPDATE_URL)" \
	-o "$output.zsync"


sha256sum "$output" > "$output.sha256sum"
md5sum "$output" > "$output.md5sum"

printf "%s\n" \
	"successfully generated '$output'." \
	"---------------------------------" \
	""

ls --color -l $output*
